## نظرة عامة على المشروع

عملت على **Digital Corporate Banking**، منصة متعددة المستأجرين تمكّن المؤسسات المالية الأفريقية من تقديم خدمات مصرفية للشركات رقمية بالكامل. خلال فترة عملي لمدة سنتين كـ **Senior Backend Developer وTechnical Lead**، توليت مسؤولية قرارات الهندسة المعمارية بعد مغادرة المهندس المعماري الأصلي، حيث عملت كمهندس معماري بحكم الأمر الواقع مع الحفاظ على تعدد استخداماتي عبر المجموعة التقنية الكاملة—مما أبقى المشروع على المسار الصحيح من خلال التكيف الرشيق مع التحديات المتطورة.

تخدم المنصة العديد من المؤسسات المالية عبر غرب أفريقيا، بما في ذلك البنوك التجارية والسلطات المصرفية المركزية. عرض القيمة الأساسي للمنتج هو **القابلية للتكوين بدون تغييرات في الكود**—حيث يمكن لكل عميل بنكي تحديد التسلسلات الهرمية للموافقة الخاصة به، وقواعد المعاملات، وسير العمل التشغيلي من خلال التكوين بدلاً من التطوير المخصص.

<p align="center">
  <img src="/portfolio-data/diagrams/Hexagonal-architecture.drawio.svg" alt="Corporate Banking System Architecture - Hexagonal architecture layers, aggregate boundaries, Sopra integration adapters, CQRS event flow" />
</p>

## التحدي التقني

اعتمدت منصات الخدمات المصرفية للشركات التقليدية على سير عمل صارم ومشفر بشكل ثابت لم يكن بإمكانه التكيف مع الهياكل التنظيمية المختلفة دون تطوير مخصص. كان التحدي الأساسي هو بناء **محرك يعتمد على القواعد** حيث تكون منطق الأعمال عبارة عن بيانات، وليس كود—مما يتيح قابلية التكوين متعددة المستأجرين دون قواعد كود لكل عميل.

صممنا منصة حيث **القواعد القابلة للتكوين تقود سلوك النظام**. يقوم محرك القواعد بتقييم سير عمل الموافقة الديناميكي بناءً على سمات المعاملات، وتطبيق سلاسل التحقق متعددة المستويات المكونة لكل مستأجر. هذا النهج المعماري أزال دورات التطوير لكل عميل وقلل وقت الوصول إلى السوق من أشهر إلى أسابيع.

**الإنجاز التقني الرئيسي**: DSL (Domain-Specific Language) قائم على الصيغ يسمح لغير المطورين بتكوين منطق موافقة معقد من خلال قواعد تعتمد على البيانات بدلاً من تغييرات الكود.

## المجموعة التقنية والأساس المنطقي

**Backend**: Java 17 مع Spring Boot 3.4
- اختيار Java 17 لاستقرار LTS وvirtual threads (مكاسب أداء بدون تعقيد)
- Spring Boot 3.4 للنظام البيئي الناضج والقابلية للملاحظة المدمجة (Actuator، Micrometer)
- هندسة DDD عملية دون الإفراط في هندسة event sourcing (نمط CQRS لفصل القراءة/الكتابة)

**Frontend**: React 18 مع design systems لواجهات العميل/الوكيل، JSF للـ backoffice
- React مع design systems ضمنت UI/UX متسقة عبر الوحدات وسرّعت تطوير الميزات
- JSF مناسب لاحتياجات backoffice لدينا (تطوير CRUD سريع، مألوف للفريق)
- ساهمت في كليهما: قدت تطوير backoffice بـ JSF، أصلحت أخطاء حرجة في خدمات React

**Data**: Oracle/PostgreSQL (يعتمد على العميل)، Elasticsearch لـ audit trails
- قواعد بيانات علائقية لسلامة المعاملات (حسابات متعددة العملات، التحويلات، الموافقات)
- Elasticsearch يوفر سجلات تدقيق غير قابلة للتغيير للامتثال التنظيمي—كل إجراء مؤرخ وقابل للبحث

**Infrastructure**: Kubernetes داخلي للنشر الداخلي مع GitLab CI/CD
- البنية التحتية الداخلية للشركة تعمل على Kubernetes داخلي
- نموذج النشر متعدد المستأجرين يسمح بمثيلات معزولة لكل عميل بنكي
- تعاونت مع DevOps لتصميم pipeline (المزيد من التفاصيل لاحقاً)

**Shared Platform**: مجموعة Proxym الداخلية توفر API Gateway، Keycloak (الهوية)، الخدمات المشتركة
- تجنب إعادة اختراع المصادقة، إدارة المستخدمين، دعم اللغات المتعددة
- سمح لنا بالتركيز على منطق المجال المصرفي بدلاً من السباكة الأساسية

## الهندسة المعمارية: DDD عملي مع تصميم سداسي

نظمنا قاعدة الكود حول **سياقات المجال** بحدود واضحة:

**Core Domains**:
- **Companies & Workspaces**: الأساس متعدد المستأجرين. يمكن للمستخدمين الانتماء إلى شركات متعددة وتبديل workspaces داخل جلسة تسجيل دخول واحدة
- **Transaction Rules Engine**: الصيغ التي تحدد متطلبات البدء/التحقق بناءً على حدود المبلغ، أنواع الحسابات، وأنواع الخدمات (سأفصل هذا أدناه—إنه قلب النظام)
- **Transaction Workflows**: آلة الحالة التي صممتها والتي تنسق البدء، التحققات، الرفض عبر جانبي الشركة والوكيل المصرفي
- **Services & Permissions**: Spring `@PreAuthorize` يؤمن endpoints بناءً على تعيينات الخدمة على مستوى loginAccount. الأقسام تحدد الخدمات التي يكون حساب تسجيل الدخول مؤهلاً لتلقيها
- **Bundles**: حزم من الخدمات بنطاقات أسعار مختلفة بناءً على مستوى اشتراك الشركة مع البنك

**Feature Domains**:
- **Beneficiaries**: إدارة المستفيدين المحليين والدوليين مع تكامل سير العمل
- **Transfers**: التحويلات القياسية، الدائمة، القائمة على الملفات، والدفعية—جميعها مدفوعة بسير العمل
- **Checkbooks، Cards، Credit Simulations، Credit Requests**: كل منها يستفيد من نفس محرك سير العمل
- **Reference Data**: البنوك، الفروع، العملات، البلدان للتوطين

**Hexagonal Architecture**:
- **Domain Core**: منطق أعمال نقي، لا توجد تبعيات للبنية التحتية
- **Ports**: واجهات تحدد العقود (مثل `CoreBankingPort` لعمليات الحساب)
- **Adapters**: تطبيقات خاصة بـ CBS (Sopra Banking، Temenos T24)

هذا الفصل أثبت أهميته عند دمج أنظمة مصرفية مركزية غير متجانسة (المزيد أدناه).

**نمط CQRS**:
- الأوامر تعدل الحالة من خلال aggregates (إنشاء تحويل، الموافقة على معاملة)
- الاستعلامات تصل إلى نماذج قراءة محسّنة (عروض لوحة المعلومات، سجلات المعاملات)
- لا event sourcing—أبقيناه بسيطاً مع معاملات قاعدة البيانات وmسارات تدقيق Elasticsearch

![CQRS Flow - Command/Query separation, write model aggregates, read model projections](/portfolio-data/diagrams/DDD-arch.drawio.svg)

### تفاصيل تنفيذ الهندسة المعمارية

**أنماط تصميم Aggregate**:
- **Transaction Aggregate**: الكيان الجذري يفرض الثوابت (كفاية الرصيد، نصاب الموافقة)
- **Workspace Aggregate**: يغلف منطق التعددية للمستأجرين والتحكم في الوصول
- تتواصل Aggregates عبر domain events (Spring ApplicationEventPublisher)
- لا توجد مراجع مباشرة لـ aggregate—فقط عن طريق ID للحفاظ على الحدود

**Domain Events & Event Handling**:
- يتم نشر domain events داخل حدود المعاملة باستخدام `@TransactionalEventListener(phase = BEFORE_COMMIT)`
- معالجات الأحداث تحدث نماذج القراءة، ترسل الإشعارات، تبطل الذاكرة المؤقتة
- يتم تخزين الأحداث في Elasticsearch لمسار التدقيق والاستعلامات الزمنية
- آلية إعادة المحاولة لمعالجات الأحداث الفاشلة (Spring Retry مع exponential backoff)

**إدارة حدود المعاملات**:
- `@Transactional` على مستوى الخدمة، وليس على مستوى المستودع (معاملات خشنة الحبيبات)
- Pessimistic locking لتحديثات رصيد الحساب لمنع race conditions
- Optimistic locking (`@Version`) لمعظم aggregates الأخرى
- تجنب المعاملات الموزعة—الاتساق النهائي عبر نشر الأحداث غير المتزامن

**أنماط التصميم المطبقة**:
- **Strategy Pattern**: مطابقات القواعد، اختيار adapter CBS
- **Template Method**: مراحل سير العمل (precheck → initiate → validate → execute)
- **Factory Pattern**: إنشاء سياق المعاملة (Single/Bulk/Batch)
- **Builder Pattern**: بناء aggregate معقد (TransactionBuilder، RuleBuilder)
- **Anti-Corruption Layer**: محولات CBS تخطط النماذج الخارجية لـ aggregates المجال

## الابتكار الأساسي: قواعد المعاملات + سير العمل

كانت هذه الميزة التي أفتخر بها أكثر من حيث التصميم والتنفيذ (بعد التوجيه الأولي من مهندسنا المعماري قبل مغادرته).

### قواعد المعاملات: محلل الصيغ ومحرك التقييم

**التنفيذ التقني** لمحرك القواعد القابل للتكوين الذي صممته:

**هندسة Formula DSL**:
- بناء Domain-Specific Language مخصص لصيغ الموافقة المخزنة كسلاسل نصية في قاعدة البيانات
- **Lexer** يحول سلاسل الصيغ إلى رموز (`×`، `+`، `OR`، `AND`)، معاملات (معرفات الدور)، وأقواس
- **Recursive descent parser** يبني Abstract Syntax Tree (AST) من الرموز
- **Evaluator** يجتاز AST في وقت التشغيل، يحل معرفات الدور مقابل سياق المستخدم
- ASTs المحللة المخزنة مؤقتاً في الذاكرة (Caffeine cache) لتجنب إعادة التحليل في كل معاملة

**تدفق تقييم القواعد**:
```java
// Pseudocode مبسط
RuleEngine {
  evaluateFormula(String formula, UserContext context) {
    AST tree = parseAndCache(formula); // Cache hit ~95% من الطلبات
    return tree.evaluate(context);     // يجتاز العقد، يتحقق من عضوية الدور
  }
}
```

**استراتيجية مطابقة القواعد**:
- كل نوع خدمة لديه قواعد متعددة مع شروط المسند (نطاقات المبالغ، أنواع الحسابات)
- **Strategy Pattern**: مطابقات قواعد مختلفة للقواعد القائمة على المبلغ، نوع الحساب، خاصة بالخدمة
- استعلام قاعدة البيانات مع المسندات المفهرسة يختار القواعد المطابقة بكفاءة
- يتم تقييم القواعد بترتيب الأولوية حتى أول تطابق

**تحسينات الأداء**:
- الصيغ المحللة مسبقاً المخزنة مؤقتاً لتجنب عبء التحليل
- مسندات القواعد المفهرسة لاسترجاع سريع من قاعدة البيانات
- تقييم دفعي لسياقات المعاملات الجماعية (مئات المعاملات التي يتم تقييمها في تمريرة واحدة)

هذه الهندسة المعمارية أزالت منطق الموافقة المشفر بالكامل—العملاء الجدد ينضمون من خلال تكوين بيانات القواعد، وليس نشر الكود.

### سير عمل المعاملات: تنسيق الشركات + الوكيل المصرفي

صممت آلة الحالة هذه للتعامل مع ثلاثة سياقات معاملات:

1. **Single Context**: معاملة واحدة، سلسلة موافقة مباشرة
2. **Bulk Context**: معاملات متعددة مع تحققات فرعية (مثل الموافقة على 8 من 10، رفض 2)
3. **Batch Context**: تحميلات الملفات مع مئات التحويلات المعالجة بشكل ذري

**PreChecks & Verifications**:
قبل بدء سير العمل، يقوم النظام بإجراء تحققات شاملة:
- التحقق من رصيد الحساب (التحقق من كفاية الأموال)
- التحقق من معاملات القطاع (حدود المعاملات، العملات المسموح بها)
- قواعد التوجيه الذكي التي تعيد توجيه السياقات إلى الوكلاء المصرفيين بدلاً من حظر المستخدمين
- فحوصات الامتثال لقواعد الأعمال

**جانب الشركة**: 
- محرك سير العمل المخصص الذي بنيته يتعامل مع البدء → التحقق → الإكمال
- يدعم الموافقات الجزئية، الرفض مع التعليقات، التفويض

**جانب الوكيل المصرفي**: 
- متكامل مع **Flowable** (محرك سير عمل BPMN) للتحققات المصرفية متعددة الخطوات المعقدة
- موافقة أحادية أو متعددة المستويات اعتماداً على سياسات البنك
- يمكن للوكلاء المصرفيين التحقق أو الرفض أو الإرسال للتصحيحات

## طبقة التكامل: تنفيذ محول CBS

تتطلب الخدمات المصرفية للشركات تكاملاً وثيقاً مع أنظمة الخدمات المصرفية الأساسية (CBS). قمنا بدمج منصات CBS متعددة بتعقيد تقني متفاوت:

**تكامل Sopra Banking Platform** (SOAP/XML):

*التحقق من XML Schema*:
- تعليقات JAXB `@XmlRootElement` على نماذج المجال لـ marshaling/unmarshaling
- مخططات XSD يتم التحقق منها مقابل XML الوارد/الصادر باستخدام `SchemaFactory`
- محولات JAXB مخصصة لتنسيق التاريخ/الوقت (ISO 8601 مقابل تنسيقات خاصة بـ CBS)

*Retry & Resilience*:
- Spring Retry (`@Retryable`) مع exponential backoff (أولي 1s، max 30s، مضاعف 2x)
- نمط Circuit breaker باستخدام Resilience4j (مفتوح بعد 5 إخفاقات، نصف مفتوح بعد 60s)
- آلية الاحتياطي: وضع الطلبات الفاشلة في قائمة الانتظار لإعادة المحاولة اليدوية عبر واجهة المسؤول

*استراتيجية تعيين الأخطاء*:
- أخطاء SOAP CBS المعينة لاستثناءات المجال عبر `SoapFaultMapper` المخصص
- جدول ترجمة رموز الخطأ (رموز خطأ CBS → أنواع أخطاء المجال)
- إثراء الخطأ السياقي (تضمين معرف المعاملة، رقم الحساب في الاستثناء)

*إدارة الاتصال*:
- Apache CXF `HTTPConduit` مع connection pooling (max 20 اتصال لكل مثيل CBS)
- Read timeout: 30s، connection timeout: 10s
- Keep-alive مفعل لإعادة استخدام اتصالات TCP

**تكامل Temenos T24** (REST/JSON):

*تكوين RestTemplate*:
- `RestTemplate` مخصص مع `ClientHttpRequestInterceptor` لحقن رمز المصادقة
- Connection pooling عبر `HttpComponentsClientHttpRequestFactory`
- إلغاء تسلسل JSON مع Jackson `ObjectMapper` (snake_case → camelCase)

*تحديد المعدل*:
- محدد معدل جانب العميل (Guava RateLimiter) لاحترام حدود API CBS (100 req/min)
- قائمة انتظار الطلبات عند الاقتراب من الحد

**Anti-Corruption Layer**:
- نمط Adapter يعزل نماذج CBS عن نماذج المجال
- طبقة التعيين (`CBSAccountMapper`، `CBSTransactionMapper`) تحول بين التمثيلات الخارجية والداخلية
- domain events لا تعرض أبداً هياكل بيانات خاصة بـ CBS

**الدرس الرئيسي**: سمح لنا تجريد `CoreBankingPort` بتبديل تطبيقات CBS في منتصف المشروع دون إعادة هيكلة منطق المجال. عندما طلب عميل بائعاً مختلفاً، قمنا بتنفيذ محول جديد في ~2 أسابيع مقابل شهور من التغييرات على مستوى النظام.

## تنفيذات الميزات التقنية

**Multi-Workspace Isolation**:
- سياق المستأجر مُدار عبر اعتراض Spring AOP + نشر ThreadLocal
- تعليقات Hibernate `@Filter` تفرض الأمان على مستوى الصف على مستوى ORM
- تبديل Workspace المنفذ بدون إبطال الجلسة (تبديل السياق فقط)
- تقييم الأذونات يستخدم Spring Security `@PreAuthorize` مع تعبيرات SpEL تشير إلى الصلاحيات المحددة بنطاق workspace

**قابلية إعادة استخدام محرك سير العمل**:
- تجريد محرك سير عمل واحد يدعم أنواع معاملات متعددة (التحويلات، طلبات البطاقات، طلبات الائتمان)
- نمط Template Method لمراحل سير العمل الشائعة (initiation → validation → execution)
- معالجة سياق المعاملة متعددة الأشكال (Single، Bulk، Batch) مع قواعد انتقال حالة مختلفة

**Batch Processing Pipeline**:
- تحميل CSV → تحليل Apache Commons CSV → خط أنابيب التحقق → إدراج دفعي في قاعدة البيانات
- معالجة قائمة على القطع مع إطار عمل Spring Batch (قطع من 100 معاملة)
- تراجع معاملات لكل قطعة (الكل أو لا شيء داخل القطعة، نجاح جزئي عبر القطع)
- معالجة غير متزامنة مع تتبع التقدم (إشعارات WebSocket للواجهة الأمامية)

## الأداء والقابلية للتوسع

**عزل بيانات التعددية للمستأجرين**:
- نهج المخطط المشترك مع عمود تمييز المستأجر (`workspace_id`)
- الأمان على مستوى الصف مفروض عبر تعليقات Hibernate `@FilterDef` و`@Filter`
- سياق المستأجر المحقون عبر نصيحة Spring AOP `@Before` على طبقة الخدمة
- ThreadLocal يخزن سياق workspace الحالي، ينتشر عبر المكالمات غير المتزامنة عبر `TaskDecorator`
- تجميع الاتصال لكل مستأجر تم تجنبه (تجمع HikariCP المشترك مع التحجيم الديناميكي)

**استراتيجية التخزين المؤقت**:
- **L1 Cache**: ذاكرة التخزين المؤقت لجلسة Hibernate (تلقائية، لكل معاملة)
- **L2 Cache**: Redis لذاكرة التخزين المؤقت للكيان الموزع عبر المثيلات
  - تجريد Spring Cache (`@Cacheable`، `@CacheEvict`، `@CachePut`)
  - التخزين المؤقت على مستوى الكيان لبيانات المرجع غير القابلة للتغيير (العملات، البلدان، البنوك)
  - التخزين المؤقت لنتائج الاستعلام لتجميعات لوحة المعلومات (TTL: 5 دقائق)
- **إبطال الذاكرة المؤقتة**: domain events تطلق `@CacheEvict` على مناطق الذاكرة المؤقتة ذات الصلة
- **استراتيجية مفتاح الذاكرة المؤقتة**: `workspace_id + entity_id` لمنع تلوث الذاكرة المؤقتة عبر المستأجرين

**التحكم في التزامن**:
- **Optimistic Locking**: تعليق `@Version` على معظم aggregates (Transaction، Workspace)
- **Pessimistic Locking**: `@Lock(PESSIMISTIC_WRITE)` لتحديثات رصيد الحساب لمنع الإنفاق المزدوج
- **Distributed Locks**: أقفال قائمة على Redis (Redisson) للتنسيق عبر المثيلات (مثل تنفيذ batch job)
- **منطق إعادة المحاولة**: Spring Retry مع exponential backoff لـ `OptimisticLockException`

**تحسين قاعدة البيانات**:
- الأعمدة المفهرسة: `workspace_id`، `transaction_status`، `created_at`، `amount` (لاستعلامات النطاق)
- الفهارس المركبة لأنماط الاستعلام الشائعة (`workspace_id + status + created_at`)
- منع استعلامات N+1 عبر `@EntityGraph` لجلب حريص لارتباطات محددة
- تمكين جلب دفعي (`hibernate.default_batch_fetch_size=20`)
- الاستعلامات للقراءة فقط مُعلّمة بـ `@Transactional(readOnly = true)` للتحسين

**التوسع الأفقي**:
- الخدمات عديمة الحالة تمكن التوسع التلقائي للبودات الأفقية (HPA) في Kubernetes
- بيانات الجلسة مخزنة في Redis (ليس في الذاكرة) لموازنة الحمل بدون sticky-session
- معالجة المهام غير المتزامنة عبر message queue (مستقبلاً: Kafka/RabbitMQ) للمهام الخلفية

## نمذجة البيانات والاستمرارية

**تصميم كيان JPA**:
- **Single Table Inheritance** لأنواع المعاملات (Transfer، CardRequest، CreditRequest)
  - `@Inheritance(strategy = InheritanceType.SINGLE_TABLE)`
  - `@DiscriminatorColumn(name = "transaction_type")`
- **Embedded Value Objects**: `@Embeddable` لـ Money (المبلغ + العملة)، Address
- **Bi-directional Associations**: `@JsonIgnore` على الجانب العكسي لمنع دورات التسلسل
- **استراتيجية التحميل الكسول**: `LAZY` افتراضياً للمجموعات، `EAGER` فقط للمسارات الحرجة مع `@EntityGraph`

**تطور المخطط**:
- **Liquibase** لإدارة تغييرات قاعدة البيانات
- مجموعات التغيير القائمة على XML المنظمة لكل إصدار (`db/changelog/v1.0.0/`، `v1.1.0/`)
- الترحيل الآلي عند بدء التطبيق (`liquibase.enabled=true`)
- نصوص التراجع للترحيلات الحرجة (مثل حذف الأعمدة، تغييرات النوع)
- مجموعات تغيير منفصلة للتطوير (بيانات الاختبار) مقابل الإنتاج (DDL فقط)

**تنفيذ مسار التدقيق**:
- اعتراض تدقيق مخصص عبر `@EntityListeners(AuditListener.class)`
- `AuditListener` يلتقط تغييرات الكيان (created_by، created_at، modified_by، modified_at)
- الفهرسة غير المتزامنة لـ Elasticsearch للبحث الكامل عن النص والاستعلامات الزمنية
- سجلات التدقيق غير القابلة للتغيير (إدراج فقط، لا تحديثات/حذف)
- تقسيم جدول التدقيق حسب الشهر لأداء الاستعلام

**إدارة المعاملات**:
- `@Transactional` على مستوى الخدمة (معاملات خشنة الحبيبات)
- Propagation.REQUIRES_NEW لتسجيل التدقيق (معاملة مستقلة)
- Isolation.READ_COMMITTED لمعظم العمليات (يمنع القراءات القذرة)
- Isolation.SERIALIZABLE للعمليات المالية الحرجة (تحديثات رصيد الحساب)

## CI/CD & Quality Gates

تعاونت مع DevOps لتصميم **pipeline monorepo** مع كشف التغيير الذكي والتنفيذ المتوازي:

**هيكل GitLab CI/CD Pipeline**:

*مرحلة Build*:
- **Conditional Builds**: تحليل git diff يحدد الوحدات المتغيرة (backend، customer-frontend، agent-frontend، backoffice)
- **Parallel Jobs**: كل وحدة تُبنى بشكل مستقل (Maven للـ backend، npm للواجهات الأمامية)
- **Build Caching**: تبعيات Maven مخزنة مؤقتاً عبر تشغيلات pipeline (~70% builds أسرع)
- **Docker Multi-Stage Builds**: صور build وruntime منفصلة لمصنوعات إنتاج أصغر

*مرحلة Analysis*:
- **SonarQube**: تحليل ثابت مع quality gates (80% تغطية كود، 0 مشكلات حاجبة، < 3% تكرار كود)
- **PMD**: قواعد جودة كود Java (مقاييس التعقيد، الاستيرادات غير المستخدمة، أفضل الممارسات)
- **OWASP Dependency Check**: يفحص التبعيات الضعيفة (يفشل البناء على CVEs عالية/حرجة)
- **Security Hotspot Analysis**: مراجعة يدوية مطلوبة لأنماط الأمان المكتشفة

*مرحلة Test*:
- **Unit Tests**: JUnit 5 + Mockito (الهدف: 80% تغطية، مفروضة بواسطة Jacoco)
- **Integration Tests**: Testcontainers يطلق حاويات Postgres + Elasticsearch + Redis
  - إعادة تعيين حالة قاعدة البيانات بين الاختبارات عبر rollback Liquibase
  - ملفات تعريف خاصة بالاختبار (`application-test.yml`)
- **Contract Tests** (مستقبلاً): Pact لعقود API الواجهة الأمامية والخلفية

*مرحلة Publish*:
- **Artifact Publishing**: مستودع Nexus لمصنوعات Maven (snapshot مقابل release بناءً على الفرع)
- **Docker Image Build**: صور متعددة البنى (amd64، arm64) مدفوعة إلى GitLab Container Registry
- **استراتيجية Image Tagging**:
  - `latest` لفرع main
  - `${GIT_COMMIT_SHA}` للتتبع
  - `${VERSION}-${BRANCH_NAME}` لفروع الميزات

*مرحلة Deploy*:
- **Development Environment**: نشر تلقائي عند الدمج في main (Kubernetes rolling update)
- **QA/Demo Environments**: تشغيل يدوي مع بوابات الموافقة
- **Deployment Health Checks**: تحقيقات Kubernetes readiness/liveness تضمن عمليات نشر بدون توقف
- **استراتيجية التراجع**: نسخة الصورة السابقة محفوظة في السجل للتراجع السريع

**Merge Request Pipeline**:
- **التحققات قبل الدمج**:
  - تنسيق Conventional Commits (commitlint)
  - فحص جودة وصف MR (min 50 حرفاً، يجب أن يشير إلى مشكلة)
  - لا تعارضات في الدمج
  - جميع المناقشات محلولة
- **الفحوصات الآلية**: Build + unit tests + integration tests يجب أن تنجح
- **Code Review**: الحد الأدنى 1 موافقة مطلوبة (CODEOWNERS مفروض)

**استراتيجية ترقية البيئة**:
```
Development (تلقائي) → QA (يدوي) → Demo (يدوي) → UAT (يدوي)
```

**البنية التحتية للاختبار**:
- Testcontainers لاختبارات التكامل (قاعدة بيانات معزولة لكل مجموعة اختبار)
- Kubernetes namespace لكل بيئة (dev، qa، demo، uat)
- الأسرار تُدار عبر متغيرات GitLab CI/CD (تُحقن في وقت التشغيل)

<!-- DIAGRAM: CI/CD Pipeline - Stages, conditional builds, environment promotion -->

## القابلية للملاحظة والأمان

**المراقبة والقابلية للملاحظة**:
- **Spring Actuator**: مؤشرات صحة مخصصة لاتصال CBS، توفر Redis، تجمع اتصال قاعدة البيانات
- **Elasticsearch Audit Trail**: سجلات الأحداث غير القابلة للتغيير المفهرسة بمعرف المعاملة، معرف المستخدم، معرف workspace، الطابع الزمني
- **Exception Auditing**: `@ControllerAdvice` المخصص يلتقط الاستثناءات بسياق كامل (معاملات الطلب، الرؤوس، معلومات المستخدم)
- **Metrics**: تكامل Micrometer ينشر إلى Prometheus (إنتاجية المعاملات، معدل إصابة الذاكرة المؤقتة، كمون CBS)
- **Distributed Tracing** (مستقبلاً): OpenTelemetry لارتباط التتبع عبر الخدمات

**تنفيذ الأمان**:

*المصادقة والتفويض*:
- **Keycloak** كموفر هوية OAuth2/OIDC (إدارة مستخدم مركزية)
- **JWT Tokens**: رموز الوصول مع مطالبات مخصصة (workspace_id، roles، permissions)
- **Spring Security Filter Chain**:
  - `JwtAuthenticationFilter` يستخرج ويتحقق من توقيع JWT (RSA256)
  - `WorkspaceContextFilter` يملأ ThreadLocal من مطالبات الرمز
  - تعبيرات SpEL `@PreAuthorize` للتحكم في الوصول على مستوى الطريقة

*التحكم في الوصول القائم على الدور (RBAC)*:
```java
// أمثلة على قواعد التفويض
@PreAuthorize("hasAuthority('PERM_TRANSFER_INITIATE') and #workspaceId == principal.workspaceId")
public void initiateTransfer(Long workspaceId, TransferRequest request)

@PreAuthorize("hasRole('ROLE_ADMIN') or @permissionEvaluator.canAccessTransaction(#transactionId)")
public Transaction getTransaction(Long transactionId)
```

*تشفير البيانات*:
- **في الراحة**: JPA `@Convert` مع `AttributeConverter` للحقول الحساسة (أرقام الحسابات، تفاصيل البطاقات)
- **AES-256-GCM** encryption باستخدام Spring Crypto utilities
- **Key Management**: مفاتيح التشفير مخزنة في متغيرات البيئة (مُعدة لـ AWS KMS/Azure Key Vault)
- **في النقل**: TLS 1.3 مفروض لجميع الاتصالات الخارجية

*رؤوس الأمان*:
- Spring Security مهيأ برؤوس موصى بها من OWASP
- Content Security Policy (CSP)، X-Frame-Options، X-Content-Type-Options
- CORS مهيأ مع قائمة سماح للأصول المسموح بها

## التوثيق ونقل المعرفة

أحد الجوانب التي أفتخر بها بشكل خاص: **التوثيق الشامل**. مع العلم أن هذا سيكون منتجاً منشوراً لعملاء متعددين، قمت بـ:

- توثيق كل مفهوم من مفاهيم المجال، وحالة سير العمل، وخيار التكوين
- إنشاء أدلة الإعداد للمطورين الجدد
- كتابة كتيبات تكامل CBS (غرائب Sopra، أنماط Temenos)
- الحفاظ على architecture decision records (ADRs) للاختيارات الرئيسية

سيسمح هذا لـ Proxym بإعداد عملاء مستقبليين باحتكاك أدنى—الفرق الجديدة يمكنها فهم النظام دون معرفة قبلية.

## التأثير والتأمل

**ميزة الوقت إلى السوق**: 
محرك القواعد القابل للتكوين يعني أن العملاء الجدد ينشرون في **أسابيع، وليس أشهر**. لا يوجد تطوير مخصص لسير عمل الموافقة—فقط التكوين. هذا يضع Proxym في موقع تنافسي في سوق الرقمنة المصرفية الأفريقية.

**المرونة المعمارية**: 
عندما غادر مهندسنا المعماري، سمحت لنا الهندسة السداسية النظيفة والسياقات المحددة بالاستمرار دون إعادة هيكلة كبيرة. يمكن للمطورين الجدد العمل على ميزات معزولة (مثل Cards، Credits) دون كسر الأساس.

**النمو الشخصي**: 
الانتقال إلى دور المهندس المعماري بحكم الأمر الواقع علمني التوازن بين **البراغماتية وأفضل الممارسات**. تخطينا event sourcing (معقد جداً لاحتياجاتنا)، لكن احتفظنا بـ CQRS لتحسين القراءة/الكتابة. استخدمنا Flowable فقط حيث كان ضرورياً (سير عمل الوكيل المصرفي)، وليس في كل مكان. الهندسة المعمارية الجيدة ليست عن استخدام كل نمط—بل عن حل المشاكل الحقيقية بكفاءة.

**ما التالي**:
بينما ينتقل العملاء نحو النشر في الإنتاج، سنحصل على بيانات أداء حقيقية وملاحظات المستخدمين. النظام مصمم للتوسع أفقياً (خدمات عديمة الحالة، قاعدة بيانات جاهزة للتجزئة)، وأنا واثق من أنه سيتعامل مع أحجام المعاملات للعمليات المصرفية متعددة البلدان عبر غرب أفريقيا.
