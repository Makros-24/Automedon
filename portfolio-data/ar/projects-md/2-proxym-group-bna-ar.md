## وحدة الاشتراكات: البناء من أجل التغيير

قمت ببناء وحدة اشتراكات عملاء عامة لمنصة مصرفية رقمية للبيع بالتجزئة. كان التحدي الأساسي هو تصميم نظام قادر على التعامل مع أنواع متعددة من العملاء—عملاء الأعمال، والعملاء الأفراد، وأصحاب الحسابات—كل منهم بقواعد التحقق الخاصة به، ومتطلبات KYC، وسير عمل الموافقات المختلفة. كان يجب أن يبقى النظام مرنًا مع الحفاظ على تغطية اختبارات عالية دون الاعتماد على خدمات خارجية.

بالاعتماد على خبرتي من المشاريع السابقة، كنت أعرف مسبقًا أن المتطلبات ستتطور. ما بدأ كاشتراك بسيط من نوع واحد توسع بسرعة إلى ثلاثة أنواع مختلفة في منتصف المشروع. بدلاً من البناء للمتطلبات الحالية، قمت بالبناء من أجل التغيير.

## النهج التقني: Design Patterns في العمل

قمت بهيكلة الوحدة حول عدة design patterns تعمل معًا للتعامل مع التعقيد:

**Strategy Pattern** شكّل العمود الفقري. كل نوع اشتراك يطبّق interface مشتركة مع منطق التحقق الخاص به، ومتطلبات KYC، ومعالجة workflow. عندما يختار المستخدم نوع اشتراك، يقوم النظام بتحميل الاستراتيجية الصحيحة في runtime. لا conditionals فوضوية، ولا سلاسل if-else متشعبة. عندما تم طلب نوع الاشتراك الثالث في منتصف المشروع، أضفته بسرعة من خلال تطبيق الـ interface وتسجيله في الـ factory—دون أي تغييرات على كود الـ orchestration الأساسي.

**Factory Pattern** يتعامل مع اختيار الاستراتيجية. الـ SubscriptionStrategyFactory يختار الاستراتيجية الصحيحة بناءً على نوع الاشتراك من الطلب. Spring يقوم بعمل autowire لجميع الاستراتيجيات في الـ factory، مما يسهل إضافة أنواع جديدة دون لمس منطق الاختيار.

**Adapter Pattern** حل أكبر مشكلة في السرعة—انتظار الأنظمة الخارجية. قمت بإنشاء adapter interfaces لخدمة KYC وCore Banking System، ثم بنيت تطبيقات mock وحقيقية. الـ Mock adapters تُرجع استجابات متوقعة بناءً على patterns الإدخال (مثل الأرقام الضريبية التي تبدأ بـ "999" تؤدي إلى الرفض) وتحاكي تأخيرات الشبكة الواقعية. هذا سمح لنا بتحقيق تغطية اختبارات عالية دون أي اعتماديات خارجية—الاختبارات الوحدوية تعمل في milliseconds بدلاً من انتظار الخدمات الخارجية البطيئة.

الـ Real adapters تتكامل مع الأنظمة الفعلية باستخدام RestTemplate لـ KYC وSOAP لـ Core Banking System. تتضمن circuit breakers، ومنطق retry، ومعالجة أخطاء مناسبة. عندما تتغير الـ APIs الخارجية، فقط تطبيقات الـ adapter تحتاج إلى تحديثات—الـ interface يبقى مستقرًا.

**Decorator Pattern** أضاف القطعة النهائية—التخصيصات الخاصة بالعميل. يمكننا تغليف الاستراتيجيات الأساسية بمنطق تحقق أو إثراء إضافي دون تعديل الكود العام. هذا يحافظ على قابلية إعادة استخدام الوحدة عبر عمليات نشر مختلفة للعملاء.

## تدفق الاشتراك

يتحرك الـ workflow عبر عدة مراحل: يختار المستخدم نوع الاشتراك، يتحقق النظام من البيانات ويجري فحوصات KYC من خلال الـ adapter، ينشئ كيان prospect بشكل غير متزامن لتجنب حظر الـ UI، ثم يبدأ عملية Flowable BPMN لموافقة وكيل البنك. يراجع الوكلاء الاشتراكات في الـ JSF backoffice ويوافقون عليها أو يرفضونها. عند الموافقة، تقوم الـ service tasks بإنشاء حساب CBS وتجهيز مستخدم Keycloak. عند الرفض، يتم إخطار العملاء بإرشادات واضحة لإعادة التقديم.

يتم التعامل مع رفض KYC فورًا—يتحدث الحالة إلى KYC_REJECTED، يرسل خدمة الإشعارات email/SMS مع السبب، ويسمح النظام بإعادة التقديم مع بيانات مصححة دون إعادة تشغيل التدفق بأكمله.

## الاختبارات وCI/CD

استخدمت Mockito لعمل mock للـ adapters الخارجية في الاختبارات الوحدوية، مما أعطانا تغطية شاملة دون اعتماديات KYC أو CBS. يتم اختبار كل استراتيجية بشكل مستقل مع استجابات mock متوقعة. تستخدم اختبارات التكامل Testcontainers مع PostgreSQL—قاعدة بيانات حقيقية، خدمات خارجية mock.

يقوم الـ GitLab CI/CD pipeline بتشغيل Maven Surefire وFailsafe. تجاوزنا متطلبات التغطية بنسبة 80% ووصلنا إلى 85% على وحدة الاشتراكات. تفرض الـ SonarQube quality gates حدود دنيا—تنشر الـ builds الـ artifacts فقط بعد اجتياز جميع الاختبارات.

القضت الـ Mock adapters على الوقت المحظور في انتظار الأنظمة الخارجية. دعم تنفيذ الاختبارات السريع دورات تطوير سريعة. كان بإمكان الفريق العمل بالتوازي بينما كانت التكاملات الخارجية قيد الإنهاء.

## النتائج والعمل المستقبلي

أثبتت مجموعة الـ patterns مرونتها ضد المتطلبات المتغيرة. عندما جاء نوع الاشتراك الثالث، استغرق الأمر أيامًا بدلاً من الأسابيع التي قدّرناها لإعادة هيكلة نهج تقليدي. أتى الاستثمار في Adapter Pattern بثماره في سرعة التطوير—لا انتظار للأنظمة الخارجية، ولا مطورين محظورين.

الوحدة جاهزة للنشر لعملاء إضافيين بخلاف العميل الأول. يتيح لنا الـ Decorator Pattern إضافة تخصيصات خاصة بالعميل دون عمل fork للكود.

بالنسبة للتحسينات المستقبلية، يمكن لـ rule engine مثل Drools أن يحل محل BPMN لمنطق موافقة أكثر ديناميكية. من شأن الـ Event-driven architecture مع domain events (SubscriptionApproved، KYCRejected) أن تمكّن معالجة downstream منفصلة بشكل أفضل. الـ Redis caching حاليًا غير مستغل بشكل كافٍ—هناك فرصة لتحسين الأداء على بيانات التكوين التي يتم الوصول إليها بشكل متكرر.
